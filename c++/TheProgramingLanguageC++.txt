基本
実行プログラムは特定のハードウェアとシステム用に作られるので、マックからウィンドウズへの可搬性がないのは当たり前である
c++は静的な型付けを行う言語である、すなわち全ての実体の型は使用時点でコンパイルが知っている必要がある
関数をconstexprをする場合はできるだけ単純であるほうがいい
配列型は範囲forができる
6
numeric_limits
依存処理系と自立処理系
整数値は暗黙的にboolへと変換できる
算術式やビット単位の論理式内ではboolはintに変換される　演算結果をboolに戻す必要があるときは0はfalseで非0はtrueとなる
ポインタは暗黙的にboolへと変換できる。nullptrがfalseでそれ以外はtrue
void型　void型というものは存在しない　返却値を返さない関数の型、あるいは型が分からないオブジェクトを指すポインタの型として利用する。
処理系依存を抑えるには。非標準ライブラリではなく、なるべく標準ライブラリを使用する。
c++のオブジェクトはcharの大きさの整数倍である　intとポインタの大きさが同一であるという想定は悪である
アラインメント　きわめて処理系特有の話であまり縁がない alignof()演算子で確認することができる
c++プログラムでは名前(識別子)は利用する前に宣言しておかねばならない。　すなわち名前が表す実体をコンパイラに伝えるために型を指定する。　もし実体を利用するのであれば必ずどこかで定義しなければいけない
ほとんどの多くの宣言は定義である。定義とはその実体の利用にあたってプログラムが必要とする情報をすべて含む宣言のことである　関数宣言　変数宣言(extern)　型名宣言  値を指定する宣言はすべて定義である
関数定義と名前空間定義を除くとすべての宣言はセミコロンで終了する　後置の宣言演算子は前置のものより強く結合する
変数名を付けるときに、型に関する情報を名前に持たせる手法はおすすめしない　なぜならプログラムの抽象度が下がる、型を変更するときに置換しなければならない
初期化にかんしてautoを使わない場合は{}がよい、しかしautoを利用する場合は=を使う{}を使うメリットはない　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　
デフォルト値による初期化を行うことを表すには{}を利用する　例　char buf[max] {}ユーザ定義の場合はコンストラクタが決定する
初期化子を与えなくても静的オブジェクトは{}で初期化される
newで作成する組み込み型の変数とオブジェクトを初期化するときは{} 例　int* p { new int[max] {}}
autoはスコープが広いときは用いるべきではない 
newは名前を持たないオブジェクトをつくって割り当てている
右辺値はおおざっぱに言えば一時的なもので、左辺値ではないもの
intのような宣言されたコンストラクタをもたない型は、なにも行わないデフォルトコンストラクタとデストラクタをもっているとみなされる
末尾の_tは伝統的にtypedefによって与えられた別名を意味する
7.1
組み込みのポインタ型によって参照できる最小単位はcharであり、boolもcharと同様　ごく小さい値をコンパクトに保持したかったらビット単位の論理演算子かbitsetを利用する
void*は格納されているオブジェクトの型が不明である状態で、メモリ上のアドレスを保持したりするときに利用されるが、一般にポインタがさすオブジェクトの型とは異なる型へのキャストは安全ではない
static_castはそのような見苦しさをわざと目立たせるために開発された
void*のおもな用途は引数のオブジェクト型を仮定しない関数に引数に渡したり、オブジェクト型を仮定しない関数の戻り値にする場合であり、これらの低レベルの領域でのみ使われるべきで、高レベルで使用されてたら目を疑うべきである。

14.2 namespace


修飾構文を利用して名前空間定義の外で名前空間に新しいメンバを追加することはできない
実引数依存探査　関数呼び出しスコープと全引数の名前空間から探査がされる
クラスのメンバ関数の場合は引数による探査より同一クラスや基底クラス内のメンバが優先される
名前空間はオープンなので別の箇所で名前空間を宣言して追加することが可能である
relatedKey->関連名前空間
relatedKey->多重定義解決規則

18.1
operator T()は型Tへの型変換を行う
全ての演算子が不適切であれば、関数呼び出し記法を使う
演算子を使うのは明示的な演算子呼び出しの省略形に過ぎない
a + b -> a.operator+(b)
2項演算子は1つの引数を受け取る非staticメンバ関数、あるいは　2つの引数を受け取る非メンバ関数のいずれか
1項演算子は引数を受け取らない非staticメンバ関数、あるいは1個の引数を受け取る非スタティックメンバ関数のいずれか
=と&と,はオブジェクトクラスに対して、定義されるとそれらの演算子本来の意味が自動的に適用される
ユーザ定義型の式が勝手に変更されないように演算子はメンバ関数あるいは通常1個以上のユーザ定義型引数を受け取る関数でなければいけないnewdeleteは別
ポインタのみを扱う演算子は定義できない
第一オペランドとして組み込み型を受け取る演算子関数はメンバ関数にはできない
多くの場合演算子はなんらかの結果を返却する、新しく作ったオブジェクトを指すポインタや参照を返すのは悪、しかし引数として受け取ったオブジェクトの参照を返却するのは可能であり、通常はそうする
演算子の探索において非メンバよりメンバが優先するといった規則は存在しない、演算子を隠さないことで、組み込みの演算子が利用不可になることもない
ユーザ定義型の変数に対して、スカラによる初期化や代入を行いたいときは、スカラからユーザ定義型に変換する演算子が必要だ->1個の引数を受け取るコンストラクタを定義する　これは引数型からコンストラクタ型への変換を行う
what->自動変数とは
ドット演算子の左オペランドに対してユーザ定義型変換が行われることはない ->も 例3+z = complex(3) + z// 3.operator(z) = error
コンストラクタにconstexprをつけるとコンパイル時に作れる
コンストラクタはユーザ定義型から組み込み定義型への暗黙の変換、あたらしいクラスから定義済の古いクラスへの暗黙の変換は行わない->解決方法として変換演算子を使う
変換演算子　X::operator T() 型XからTへ変換する(返却型の記述は重複するのでしない)
explicit変換演算子　想定外の文脈での利用を抑制するP547
とあるクラスXとYを変換演算子を使って代入した時は注意ユーザ定義変換が行われるのは組み込み変換では解決できないときのみ　


friend 19.4
クラスのフレンド宣言はクラスのメンバ関数を別のクラスのフレンドとするための省略記法である
フレンドは同一スコープ内で事前に宣言しておくかあるいはfriendと宣言するクラスを囲んでいる非クラススコープ内で
定義しなければならない
最初にフレンドと宣言された名前に関しては、宣言されたときのスコープより外のスコープは考慮されない（フレンド関数として使ってもクラスのメンバにはアクセスできない
フレンド関数は同一スコープ内で明示的に宣言するか、クラスや派生クラスを引数として受け取るべき
フレンド関数はどんな時に使うべきであるのか
	内部表現を直接扱う関数はメンバとするべき直接扱うことがなければ名前空間を使用する
what->スコープと名前空間は違うの?


アクセス制御 20.5
classのデフォルトはprivate structのメンバはデフォルトでpublic
一般的に入れ子クラスは有用ではない、避けたいときはfriendを使用する
アクセス指定子によるクラス分割の順序をコンパイラが並べ替えることがある、順序の並び替えはコンパイラ依存であるので、
データメンバに対しては、同一のアクセス指定子を何度も用いるべきではない
->what->16.2.4
派生クラスが基底クラスの限定公開(protected)メンバにアクセスできるのは、自分自身の型のオブジェクトに対してのみ
protectedされたデータメンバ、は設計上の誤りであることが一般的、メンバ関数には当てはまらない
基底クラスに対するアクセス指定子(public,private,protected)は省略可能structはpublic,classはprivate
基底クラスへのたどり着く経路が複数ある場合でも、アクセス可能な経路があれば基底クラスの名前が利用できる。
しかし、経路をたどって到達するのが一つのみでなければエラー
using宣言をもちいたからといってアクセス可能な情報が増えることはない、もともとアクセス可能な情報を使いやすくするためのものにしか過ぎない
