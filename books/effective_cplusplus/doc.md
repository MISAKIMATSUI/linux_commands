#effective c++
#2018/08/19-2018/08/21

#chapter 1

P3 
	組み込みは参照渡し<値渡し ユーザー定義参照渡し>値渡し コンストラクタデストラクタ	
--- 
P4 
	定数 const ヘッダ
--- 
P4 
	`const char* const name = "test"` < `const std::string name("test")`
--- 
P5 
	クラス 定数 static
--- 
P5 ???
	クラス 整数型定数のみ 初期化 なぜ
--- 
P9
	const * 右左
--- 
P9
	const std:vector<int>::iterator const std:vector<int>::const_iterator 
--- 
P10
	operator* 返り値const なぜ
--- 
P11
	メンバ関数 const メリットオーバーロード
--- 
P12
	組み込み 関数の戻り値 変更できない
--- 
P22
	初期化 基底クラス 派生クラス 順番
--- 
P23
	異なる翻訳単位にあるローカルでない静的オブジェクトの初期化の順番は不定	
--- 
P30
	const 参照 コピー代入演算子拒否
---
P36
	仮想関数 仮想デストラクタ するべき理由
---
P36
	理由もなく仮想デストラクタ 誤り 理由
---
P37
	vector string 派生クラス 作っては行けない理由
---
P44
	コンストラクタデストラクタ 仮想関数読んではいけない理由
---
P48 [operator]
	代入演算子は*thisへの参照を返す	
---
P50 [operator]
	operator= 自己代入
---
P56 
	派生クラスのコピー関数(コピーコンストラクタとコピー代入演算子) 基底のクラスもコピーするように注意 デフォルトコンストラクタ
		>メンバにオブジェクトがあった場合.デフォルトで生成されるコピーコンストラクタとコピー代入演算子はオブジェクトをどう処理しますか？という話
---
P62
	auto_ptr STLコンテナに格納してはいけない 理由
---
P64
	auto_ptr shared_ptr 動的に確保した配列に使えない delete[]
---
P64
	リソースを直接開放しなければいけないならなにかが間違っている
---
P76 
	newで生成したオブジェクトをスマートポインタに渡すのは独立したステートメントで
---
P76 ???
	c++コンパイラ 引数評価順自由 なぜ
---
P83
	tr1::share_ptr クロスdll問題
---
P89
	スライス問題 参照
---
P91
	小さなユーザー定義型なら値渡しでいいと言えない理由
---
P100
	メンバでもフレンドでもない関数を使う カプセル化 namespace
---
P104
	24項
---
P108
	friendにしないで済むならしないほうがいい
---
P108
	swap関数 処理の中身 コピーコンストラクタとコピー代入演算子
---
P123
	`Drived d; Base *pb = &d;` 危険 理由 アドレスが変化する可能性があるらしいがよくわからん
---
P124
	キャスト 新しい一時オブジェクトを生成 危険 (本当かどうかあとで試そう)
---
P125
	dynamic_cast 遅い dynamic_castが必要になるシーンと使うのを避ける方法 (これも本当にできるのかどうか後で調べよう) 
	>vptr(オーバーライドされた仮想関数のうちどれを実行するか)
---
P130
	constオブジェクト 参照を返すメンバ関数 publicと同じ 対策は戻り値にconst
---
P142
	virtualは実行にどの定義が使われるか待つ
---
P143
	関数ポインタを通しての関数呼び出しはinline化されない
---
P152
	定義用のヘッダファイルと宣言用のヘッダファイルを分ける iosfwd
---
P163
	public継承の意味
---
167
	基底クラスや派生クラスの引数が異なっていても名前の隠蔽は行われる どうすればよいか
---
P172
	派生クラスにはvirtualをつける意味はない
---
P177
	仮想ではない関数を実装する目的
---
P188
	ポインタを通した仮想関数の呼び出し変わる理由
---
P192
	仮想関数にデフォルト引数 やっかいな理由
---
P201
	private継承 どうい場合にするか
---
