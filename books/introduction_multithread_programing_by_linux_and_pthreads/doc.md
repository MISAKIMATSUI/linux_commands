#linuxとpthreadsによるマルチスレッドプログラミング入門
#2019/10/01-2019/10/

#chapter 1

P10
	pthreadは原則として常に他のスレッド処理の割り込みが許されている（特別な場合のみ許さない)
--- 
P10
	明示的に他のスレッド処理が動ける隙間を作りたいというときはnanosleep等を使う	
--- 
P11
	CPUがどの順番でスレッドの処理をするかはOSのきまぐれ
--- 
P22
	原則としてすべてのスレッドは親子関係があるわけではなく対等である
--- 
P28
	pthread関数を呼ぶ前にthreadFuncスレッドが終了したらどうなるか
---
P31
	以前ロックをかけたのが自身ならばそれ以上ロックをかけない pthread_equal
---
P36
	スレッド停止 return pthread_exit 
---
P36
	他スレッド強制停止 やめたほうがいい理由
---
P44
	ファイルディスクリプタはオープンしたスレッドだけが書き込めるようにするべき
---
P48
	OSはスレッドごとに異なるスタック領域を確保 
---
P55
	メモリアドレスさえわかれば他のスレッドのスタック上にある自動変数にアクセスできる(いいのか
---
P64
	関数内部でグローバル変数を使っている場合、原則としてその関数はマルチスレッドセーフではない
---
P65
	使う関数がマルチスレッドであること、その使い方がマルチスレッドであること
---
P69
	スレッドローカル変数 使わない 遅い 汚い 構造体にまとめる
---
P75
	volatile変数 ソースコードに忠実に変数の値の読み出しを行うようになる
---
P86
	mutexのチェックをwhileで回し続けると無駄にCPUの消費するだけなので1マイクロスリープする
---
P90
	変数が0であることを確認してからそこに1を書き込むまでの間に他のスレッドが動作する可能性がある -> atomic
---
P91
	アトミックに行う == 処理中に他の処理が割り込まない
---
P94
	pthread_mutex_t usingPrimeNumber = PTHREAD_MUTEX_INITIALIZER;	
---
P94
	pthread_mutex_destroy関数は呼ばなくても変数が破棄されれば自動的にmutexが破棄されたことになる
---
P114
	排他しなければいけない対象をできるだけ細かな単位で設定し、その対象ごとにミューテックスを用意する
---
P117
	デッドロック パターン 3つ
---
P124
	相互ロック対策 3つ
---
P146
	メインスレッドで値が入力されるのをスリープを使って繰り返し待っているのがきれいではない -> 条件待ちを利用する
---
P149
	pthread_cond_wait関数の処理 順番 4つ
---
P169
	pthread_cond_signal関数の前のロックがないとどうなるのか またつけないパターンはどんな時?
---
P173
	画面要求が出ているかどうかを示すフラグを用意し、ミューテックスと条件変数はこのフラグの変更を同期するために使用する
---
P177
	pthread_cond_signal関数は条件成立を待っているスレッドのうちどれかを起こす、どのスレッドが起きるか定まっていない
---
P179
	pthread_cond_signal関数の呼び出しで動くスレッドは一つだけだが、厳密には保証されていない
---
P179
	条件待ちをするスレッドは条件変数一つに付き一つ
---
P185
	スタベーション
---



